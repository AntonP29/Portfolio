<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AntonP29 | Portfolio</title>
    <style>
        :root {
            --bg-dark: #121212;
            --text-light: #ffffff;
            --accent-color: #4a4a4a;
            --acrylic-opacity: rgba(0, 0, 0, 0.3);
            --border-grey: #4a4848;
            --green-acrylic: rgba(34, 139, 34, 0.3);
        }

        .project-card {
            color: inherit;
            text-decoration: none;
        }

        .project-tile.full-width {
            color: inherit;
            grid-column: span 3;
        }

        .project-card h3, .project-card p {
            color: inherit;
        }

        .project-card:visited {
            color: inherit;
        }

        .project-card:hover {
            color: inherit;
            background-color: #313131;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: auto;
        }

        body {
            font-family: 'Proxima Nova', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-light);
            line-height: 1.6;
            margin: 0;
            overflow-x: hidden;
            overflow-y: auto;
        }

        body.loading {
            overflow-y: hidden;
            position: fixed;
            width: 100%;
        }

        .background--custom {
            width: 100vw;
            height: 100vh;
            position: fixed;
            overflow: hidden;
            z-index: -2;
            top: 0;
            left: 0;
        }

        #gradient-canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            z-index: -1;
        }

        .container {
            width: 90%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 0;
            position: relative;
            z-index: 1;
            min-height: 100vh;
            opacity: 0;
            transform: translateY(20px);
            animation: floatIn 0.5s ease-out forwards;
        }

        .acrylic {
            background: var(--acrylic-opacity);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            position: relative;
            overflow: hidden;
            border: 2px solid transparent;
            transition: border 0.3s ease;
        }

        .acrylic:hover {
            border: 2px solid var(--border-grey);
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            opacity: 0;
            transform: translateY(20px);
            animation: floatIn 0.5s ease-out forwards;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
        }

        nav a {
            color: var(--text-light);
            text-decoration: none;
            margin-left: 1rem;
            transition: color 0.3s ease;
            animation: floatInText 0.5s ease-out 0.5s forwards;
            opacity: 0;
        }

        nav a:hover {
            color: #888;
        }

        .hero {
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 80vh;
            margin-top: 4rem;
            opacity: 0;
            transform: translateY(20px);
            animation: floatIn 0.5s ease-out forwards;
        }

        .hero-content {
            max-width: 600px;
            padding: 2rem;
        }

        .hero h1 {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            font-weight: bold;
            text-shadow: 
                0 0 10px rgba(255, 255, 255, 0.4),
                0 0 20px rgba(255, 255, 255, 0.3),
                0 0 30px rgba(255, 255, 255, 0.2);
            animation: floatInText 0.5s ease-out 0.5s forwards;
            opacity: 0;
        }

        .hero p {
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 2rem;
            animation: floatInText 0.5s ease-out 0.5s forwards;
            opacity: 0;
        }

        .cta-buttons {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }

        .btn {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            color: var(--text-light);
            text-decoration: none;
            background: var(--acrylic-opacity);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            position: relative;
            transition: background-color 0.3s ease, border 0.3s ease;
            animation: floatIn 0.5s ease-out forwards;
            border: 2px solid transparent;
        }

        .btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid var(--border-grey);
        }

        .btn::after {
            content: "";
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: var(--acrylic-opacity);
            border-radius: 13px;
            z-index: -1;
        }

        .projects {
            margin-top: 4rem;
            opacity: 0;
            transform: translateY(20px);
            animation: floatIn 0.5s ease-out forwards;
        }

        .projects h2 {
            text-align: center;
            margin-bottom: 2rem;
            font-weight: bold;
            animation: floatInText 0.5s ease-out 0.5s forwards;
            opacity: 0;
        }

        .project-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }

        .project-card {
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            background: var(--acrylic-opacity);
            backdrop-filter: blur(20px);
            animation: floatIn 0.5s ease-out forwards;
            opacity: 0;
            position: relative;
            border: 2px solid transparent;
            transition: border 0.3s ease;
        }

        .project-card:hover {
            border: 2px solid var(--border-grey);
        }

        .project-card:nth-child(1) { animation-delay: 0.6s; }
        .project-card:nth-child(2) { animation-delay: 0.8s; }
        .project-card:nth-child(3) { animation-delay: 1s; }

        .project-card h3 {
            margin-bottom: 0.5rem;
            font-weight: bold;
            animation: floatInText 0.5s ease-out 0.5s forwards;
            opacity: 0;
        }

        .project-card p {
            animation: floatInText 0.5s ease-out 0.5s forwards;
            opacity: 0;
        }

        footer {
            text-align: center;
            padding: 2rem 0;
            margin-top: 2rem;
            opacity: 0;
            transform: translateY(20px);
            animation: floatIn 0.5s ease-out forwards;
        }

        footer p {
            animation: floatInText 0.5s ease-out 0.5s forwards;
            opacity: 0;
        }

        @keyframes floatIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes floatInText {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 768px) {
            .hero {
                flex-direction: column;
                text-align: center;
            }

            .hero-content {
                max-width: 100%;
            }

            .cta-buttons {
                justify-content: center;
            }
        }

        @media (min-width: 768px) {
            .container, .hero, header, .projects, footer {
                animation: floatIn 0.5s ease-out forwards;
            }
        }

        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .popup {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 600px;
            height: 450px;
            background: var(--acrylic-opacity);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            border: 2px solid transparent;
            transition: border 0.3s ease;
            color: var(--text-light);
            justify-content: space-between;
        }

        .popup:hover {
            border: 2px solid var(--border-grey);
        }

        .popup h2 {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .popup .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .popup .close-btn:hover {
            opacity: 1;
        }

        .popup .message-box {
            width: 100%;
            height: 200px;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 10px;
            color: var(--text-light);
            resize: none;
            font-family: 'Proxima Nova', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        .popup .message-box::placeholder {
            color: #aaa;
            font-weight: bold;
        }

        .popup .form-bottom {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.38rem;
        }

        .popup .name-box, .popup .email-box {
            width: 100%;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 10px;
            color: var(--text-light);
            font-family: 'Proxima Nova', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            text-align: center;
        }

        .popup .name-box::placeholder, .popup .email-box::placeholder {
            color: #aaa;
            font-weight: bold;
        }

        .popup .send-btn {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            color: var(--text-light);
            text-decoration: none;
            background: var(--green-acrylic);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            border: 2px solid transparent;
            transition: background-color 0.3s ease, border 0.3s ease;
            cursor: pointer;
        }

        .popup .send-btn:hover {
            background-color: rgba(34, 139, 34, 0.5);
            border: 2px solid var(--border-grey);
        }

        .popup .send-btn::after {
            content: "";
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: var(--green-acrylic);
            border-radius: 13px;
            z-index: -1;
        }

        @media (max-width: 768px) {
            .popup {
                width: 450px;
                padding: 1rem;
                height: auto;
                min-height: 450px;
            }

            .popup .message-box {
                height: 150px;
            }

            .popup .form-bottom {
                gap: 0.4rem;
            }
        }

        nav a[href="https://github.com/AntonP29"] svg {
            position: relative;
            top: 6px;
        }

        nav a[href="#projects"],
        nav a.contact-link {
            font-weight: bold;
        }

        nav {
            position: relative;
            top: -2.75px;
        }

        nav a {
            color: var(--text-light);
            text-decoration: none;
            margin-left: 1rem;
            transition: color 0.3s ease;
            animation: floatInText 0.5s ease-out 0.5s forwards;
            opacity: 0;
            display: inline-flex;
            align-items: center;
        }

        .progress {
            background: rgba(255, 255, 255, 0.1);
            justify-content: flex-start;
            border-radius: 100px;
            align-items: center;
            position: relative;
            padding: 0 5px;
            display: flex;
            height: 20px;
            width: 100%;
            max-width: 200px;
            backdrop-filter: blur(20px);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            border: 2px solid transparent;
            transition: border 0.3s ease, opacity 0.1s ease;
            margin: 1rem auto 0;
        }

        .progress-value {
            animation: load 1.5s normal forwards;
            box-shadow: 0 10px 40px -10px #fff;
            border-radius: 100px;
            background: #fff;
            height: 14px;
            width: 0;
        }

        @keyframes load {
            0% { width: 0; }
            100% { width: 100%; }
        }

        .progress.fade-out {
            opacity: 0;
        }
    </style>
</head>
<body class="loading">
    <div class="background--custom">
        <canvas id="gradient-canvas"></canvas>
    </div>
    <div class="container">
        <header class="acrylic">
            <div class="logo">AP29</div>
            <nav>
                <a href="https://github.com/AntonP29" target="_blank">
                    <svg width="24" height="24" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0016 8c0-4.42-3.58-8-8-8z" fill="currentColor"/>
                    </svg>
                </a>
                <a href="#projects">Projects</a>
                <a href="#" class="contact-link">Contact</a>
            </nav>
        </header>

        <section class="hero">
            <div class="hero-content acrylic">
                <h1>AntonP29</h1>
                <p>HTML/CSS | Javascript | iOS Sideloading</p>
                <div class="cta-buttons">
                    <a href="#projects" class="btn">View Projects</a>
                    <a href="#" class="contact-link btn">Contact Me</a>
                </div>
                <div class="progress">
                    <div class="progress-value"></div>
                </div>
            </div>
        </section>

        <section id="projects" class="projects acrylic">
            <h2>My Projects</h2>
            <div class="project-grid">
                <a href="https://pirating.xyz" target="_blank" class="project-card">
                    <div>
                        <h3>Pirating.xyz UI</h3>
                        <p>Made the "modern" UI of the pirating.xyz website.</p>
                    </div>
                </a>
                <a href="https://repoviewer.pages.dev/" target="_blank" class="project-card">
                    <div>
                        <h3>AntonP29 iPA RepoViewer</h3>
                        <p>Web viewer for ipa repos.</p>
                    </div>
                </a>
                <a href="https://raw.githubusercontent.com/AntonP29/AntonP29-Repo/refs/heads/main/repo.json" target="_blank" class="project-card">
                    <div>
                        <h3>AntonP29 iPA Repo</h3>
                        <p>Repo with useful daily use apps (premium features unlocked). Add to your preferred signing app and enjoy!</p>
                    </div>
                </a>
                <a href="https://veyracloud.pages.dev/" class="project-tile full-width">
                    <h3>Veyra - Free Cloud Storage</h3>
                    <p>Custom Catbox.moe frontend and iPA repo manager. Upload, preview, and share your files for free with this beautiful storage solution.</p>
                </a>
            </div>
        </section>

        <footer class="acrylic">
            <p>© 2025 AntonP29. All Rights Reserved.</p>
        </footer>
    </div>

    <!-- Popup Overlay and Form -->
    <div class="popup-overlay" id="popup-overlay">
        <div class="popup">
            <h2>Contacting AntonP29!</h2>
            <button class="close-btn" id="close-btn">&times;</button>
            <form action="https://formsubmit.co/68698e12df66a644bb64375d95e5a061" method="POST" id="contact-form">
                <textarea class="message-box" name="message" placeholder="Start typing to message AntonP29..." required></textarea>
                <div class="form-bottom">
                    <input type="text" class="name-box" name="name" placeholder="Your Name" required>
                    <input type="email" class="email-box" name="email" placeholder="Your Email" required>
                    <button type="submit" class="send-btn">Send</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        if ('scrollRestoration' in history) {
            history.scrollRestoration = 'manual';
        }

        window.scrollTo(0, 0);
        document.documentElement.scrollTop = 0;
        document.body.scrollTop = 0;

        document.body.classList.add('loading');

        const lockScroll = (e) => {
            e.preventDefault();
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
        };
        window.addEventListener('scroll', lockScroll);

        const animatedElements = document.querySelectorAll('.container, .hero, header, .projects, footer, .project-card, .hero h1, .hero p, nav a, .projects h2, .project-card h3, .project-card p, footer p');
        animatedElements.forEach(el => {
            el.style.animationPlayState = 'paused';
        });

        function normalizeColor(hexCode) {
            return [(hexCode >> 16 & 255) / 255, (hexCode >> 8 & 255) / 255, (255 & hexCode) / 255];
        }

        class MiniGl {
            constructor(canvas, width, height, debug = false) {
                const _miniGl = this;
                _miniGl.canvas = canvas;
                _miniGl.gl = _miniGl.canvas.getContext("webgl", { antialias: true });
                _miniGl.meshes = [];
                const context = _miniGl.gl;
                width && height && this.setSize(width, height);
                _miniGl.debug = debug ? console.log : () => {};
                Object.defineProperties(_miniGl, {
                    Material: {
                        enumerable: false,
                        value: class {
                            constructor(vertexShaders, fragments, uniforms = {}) {
                                const material = this;
                                function getShaderByType(type, source) {
                                    const shader = context.createShader(type);
                                    context.shaderSource(shader, source);
                                    context.compileShader(shader);
                                    return shader;
                                }
                                function getUniformVariableDeclarations(uniforms, type) {
                                    return Object.entries(uniforms).map(([uniform, value]) => value.getDeclaration(uniform, type)).join("\n");
                                }
                                material.uniforms = uniforms;
                                material.uniformInstances = [];
                                const prefix = "\n              precision highp float;\n            ";
                                material.vertexSource = `\n              ${prefix}\n              attribute vec4 position;\n              attribute vec2 uv;\n              attribute vec2 uvNorm;\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, "vertex")}\n              ${getUniformVariableDeclarations(uniforms, "vertex")}\n              ${vertexShaders}\n            `;
                                material.Source = `\n              ${prefix}\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, "fragment")}\n              ${getUniformVariableDeclarations(uniforms, "fragment")}\n              ${fragments}\n            `;
                                material.vertexShader = getShaderByType(context.VERTEX_SHADER, material.vertexSource);
                                material.fragmentShader = getShaderByType(context.FRAGMENT_SHADER, material.Source);
                                material.program = context.createProgram();
                                context.attachShader(material.program, material.vertexShader);
                                context.attachShader(material.program, material.fragmentShader);
                                context.linkProgram(material.program);
                                context.useProgram(material.program);
                                material.attachUniforms(void 0, _miniGl.commonUniforms);
                                material.attachUniforms(void 0, material.uniforms);
                            }
                            attachUniforms(name, uniforms) {
                                const material = this;
                                if (!name) {
                                    Object.entries(uniforms).forEach(([name, uniform]) => material.attachUniforms(name, uniform));
                                } else if (uniforms.type === "array") {
                                    uniforms.value.forEach((uniform, i) => material.attachUniforms(`${name}[${i}]`, uniform));
                                } else if (uniforms.type === "struct") {
                                    Object.entries(uniforms.value).forEach(([uniform, i]) => material.attachUniforms(`${name}.${uniform}`, i));
                                } else {
                                    material.uniformInstances.push({
                                        uniform: uniforms,
                                        location: context.getUniformLocation(material.program, name)
                                    });
                                }
                            }
                        }
                    },
                    Uniform: {
                        enumerable: false,
                        value: class {
                            constructor(e) {
                                this.type = "float";
                                Object.assign(this, e);
                                this.typeFn = { float: "1f", int: "1i", vec2: "2fv", vec3: "3fv", vec4: "4fv", mat4: "Matrix4fv" }[this.type] || "1f";
                                this.update();
                            }
                            update(value) {
                                if (this.value !== undefined) {
                                    context[`uniform${this.typeFn}`](value, this.typeFn.startsWith("Matrix") ? this.transpose : this.value, this.typeFn.startsWith("Matrix") ? this.value : null);
                                }
                            }
                            getDeclaration(name, type, length) {
                                const uniform = this;
                                if (uniform.excludeFrom !== type) {
                                    if (uniform.type === "array") return uniform.value[0].getDeclaration(name, type, uniform.value.length) + `\nconst int ${name}_length = ${uniform.value.length};`;
                                    if (uniform.type === "struct") {
                                        let name_no_prefix = name.replace("u_", "");
                                        name_no_prefix = name_no_prefix.charAt(0).toUpperCase() + name_no_prefix.slice(1);
                                        return `uniform struct ${name_no_prefix} {\n` + Object.entries(uniform.value).map(([name, uniform]) => uniform.getDeclaration(name, type).replace(/^uniform/, "")).join("") + `\n} ${name}${length > 0 ? `[${length}]` : ""};`;
                                    }
                                    return `uniform ${uniform.type} ${name}${length > 0 ? `[${length}]` : ""};`;
                                }
                            }
                        }
                    },
                    PlaneGeometry: {
                        enumerable: false,
                        value: class {
                            constructor(width, height, n, i, orientation) {
                                context.createBuffer();
                                this.attributes = {
                                    position: new _miniGl.Attribute({ target: context.ARRAY_BUFFER, size: 3 }),
                                    uv: new _miniGl.Attribute({ target: context.ARRAY_BUFFER, size: 2 }),
                                    uvNorm: new _miniGl.Attribute({ target: context.ARRAY_BUFFER, size: 2 }),
                                    index: new _miniGl.Attribute({ target: context.ELEMENT_ARRAY_BUFFER, size: 3, type: context.UNSIGNED_SHORT })
                                };
                                this.setTopology(n, i);
                                this.setSize(width, height, orientation);
                            }
                            setTopology(e = 1, t = 1) {
                                const n = this;
                                n.xSegCount = e;
                                n.ySegCount = t;
                                n.vertexCount = (n.xSegCount + 1) * (n.ySegCount + 1);
                                n.quadCount = n.xSegCount * n.ySegCount * 2;
                                n.attributes.uv.values = new Float32Array(2 * n.vertexCount);
                                n.attributes.uvNorm.values = new Float32Array(2 * n.vertexCount);
                                n.attributes.index.values = new Uint16Array(3 * n.quadCount);
                                for (let e = 0; e <= n.ySegCount; e++)
                                    for (let t = 0; t <= n.xSegCount; t++) {
                                        const i = e * (n.xSegCount + 1) + t;
                                        n.attributes.uv.values[2 * i] = t / n.xSegCount;
                                        n.attributes.uv.values[2 * i + 1] = 1 - e / n.ySegCount;
                                        n.attributes.uvNorm.values[2 * i] = t / n.xSegCount * 2 - 1;
                                        n.attributes.uvNorm.values[2 * i + 1] = 1 - e / n.ySegCount * 2;
                                        if (t < n.xSegCount && e < n.ySegCount) {
                                            const s = e * n.xSegCount + t;
                                            n.attributes.index.values[6 * s] = i;
                                            n.attributes.index.values[6 * s + 1] = i + 1 + n.xSegCount;
                                            n.attributes.index.values[6 * s + 2] = i + 1;
                                            n.attributes.index.values[6 * s + 3] = i + 1;
                                            n.attributes.index.values[6 * s + 4] = i + 1 + n.xSegCount;
                                            n.attributes.index.values[6 * s + 5] = i + 2 + n.xSegCount;
                                        }
                                    }
                                n.attributes.uv.update();
                                n.attributes.uvNorm.update();
                                n.attributes.index.update();
                            }
                            setSize(width = 1, height = 1, orientation = "xz") {
                                const geometry = this;
                                geometry.width = width;
                                geometry.height = height;
                                geometry.orientation = orientation;
                                if (!geometry.attributes.position.values || geometry.attributes.position.values.length !== 3 * geometry.vertexCount) {
                                    geometry.attributes.position.values = new Float32Array(3 * geometry.vertexCount);
                                }
                                const o = width / -2, r = height / -2, segment_width = width / geometry.xSegCount, segment_height = height / geometry.ySegCount;
                                for (let yIndex = 0; yIndex <= geometry.ySegCount; yIndex++) {
                                    const t = r + yIndex * segment_height;
                                    for (let xIndex = 0; xIndex <= geometry.xSegCount; xIndex++) {
                                        const r = o + xIndex * segment_width, l = yIndex * (geometry.xSegCount + 1) + xIndex;
                                        geometry.attributes.position.values[3 * l + "xyz".indexOf(orientation[0])] = r;
                                        geometry.attributes.position.values[3 * l + "xyz".indexOf(orientation[1])] = -t;
                                    }
                                }
                                geometry.attributes.position.update();
                            }
                        }
                    },
                    Mesh: {
                        enumerable: false,
                        value: class {
                            constructor(geometry, material) {
                                const mesh = this;
                                mesh.geometry = geometry;
                                mesh.material = material;
                                mesh.wireframe = false;
                                mesh.attributeInstances = [];
                                Object.entries(mesh.geometry.attributes).forEach(([e, attribute]) => {
                                    mesh.attributeInstances.push({
                                        attribute: attribute,
                                        location: attribute.attach(e, mesh.material.program)
                                    });
                                });
                                _miniGl.meshes.push(mesh);
                            }
                            draw() {
                                context.useProgram(this.material.program);
                                this.material.uniformInstances.forEach(({ uniform: e, location: t }) => e.update(t));
                                this.attributeInstances.forEach(({ attribute: e, location: t }) => e.use(t));
                                context.drawElements(this.wireframe ? context.LINES : context.TRIANGLES, this.geometry.attributes.index.values.length, context.UNSIGNED_SHORT, 0);
                            }
                            remove() {
                                _miniGl.meshes = _miniGl.meshes.filter(e => e !== this);
                            }
                        }
                    },
                    Attribute: {
                        enumerable: false,
                        value: class {
                            constructor(e) {
                                this.type = context.FLOAT;
                                this.normalized = false;
                                this.buffer = context.createBuffer();
                                Object.assign(this, e);
                                this.update();
                            }
                            update() {
                                if (this.values !== undefined) {
                                    context.bindBuffer(this.target, this.buffer);
                                    context.bufferData(this.target, this.values, context.STATIC_DRAW);
                                }
                            }
                            attach(e, t) {
                                const n = context.getAttribLocation(t, e);
                                if (this.target === context.ARRAY_BUFFER) {
                                    context.enableVertexAttribArray(n);
                                    context.vertexAttribPointer(n, this.size, this.type, this.normalized, 0, 0);
                                }
                                return n;
                            }
                            use(e) {
                                context.bindBuffer(this.target, this.buffer);
                                if (this.target === context.ARRAY_BUFFER) {
                                    context.enableVertexAttribArray(e);
                                    context.vertexAttribPointer(e, this.size, this.type, this.normalized, 0, 0);
                                }
                            }
                        }
                    }
                });
                const a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                _miniGl.commonUniforms = {
                    projectionMatrix: new _miniGl.Uniform({ type: "mat4", value: a }),
                    modelViewMatrix: new _miniGl.Uniform({ type: "mat4", value: a }),
                    resolution: new _miniGl.Uniform({ type: "vec2", value: [1, 1] }),
                    aspectRatio: new _miniGl.Uniform({ type: "float", value: 1 })
                };
            }
            setSize(e = 640, t = 480) {
                this.width = e;
                this.height = t;
                this.canvas.width = e;
                this.canvas.height = t;
                this.gl.viewport(0, 0, e, t);
                this.commonUniforms.resolution.value = [e, t];
                this.commonUniforms.aspectRatio.value = e / t;
            }
            setOrthographicCamera(e = 0, t = 0, n = 0, i = -2e3, s = 2e3) {
                this.commonUniforms.projectionMatrix.value = [2 / this.width, 0, 0, 0, 0, 2 / this.height, 0, 0, 0, 0, 2 / (i - s), 0, e, t, n, 1];
            }
            render() {
                this.gl.clearColor(0, 0, 0, 0);
                this.gl.clearDepth(1);
                this.meshes.forEach(e => e.draw());
            }
        }

        class Gradient {
            constructor() {
                this.el = null;
                this.cssVarRetries = 0;
                this.maxCssVarRetries = 200;
                this.angle = 0;
                this.isLoadedClass = false;
                this.isScrolling = false;
                this.scrollingTimeout = undefined;
                this.scrollingRefreshDelay = 200;
                this.isIntersecting = false;
                this.shaderFiles = {
                    vertex: "varying vec3 v_color;\n\nvoid main() {\n  float time = u_time * u_global.noiseSpeed;\n\n  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;\n\n  vec2 st = 1. - uvNorm.xy;\n\n  float tilt = resolution.y / 2.0 * uvNorm.y;\n\n  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;\n\n  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);\n\n  float noise = snoise(vec3(\n    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,\n    noiseCoord.y * u_vertDeform.noiseFreq.y,\n    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed\n  )) * u_vertDeform.noiseAmp;\n\n  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);\n\n  noise = max(0.0, noise);\n\n  vec3 pos = vec3(\n    position.x,\n    position.y + tilt + incline + noise - offset,\n    position.z\n  );\n\n  if (u_active_colors[0] == 1.) {\n    v_color = u_baseColor;\n  }\n\n  for (int i = 0; i < u_waveLayers_length; i++) {\n    if (u_active_colors[i + 1] == 1.) {\n      WaveLayers layer = u_waveLayers[i];\n\n      float noise = smoothstep(\n        layer.noiseFloor,\n        layer.noiseCeil,\n        snoise(vec3(\n          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,\n          noiseCoord.y * layer.noiseFreq.y,\n          time * layer.noiseSpeed + layer.noiseSeed\n        )) / 2.0 + 0.5\n      );\n\n      v_color = blendNormal(v_color, layer.color, pow(noise, 4.));\n    }\n  }\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",
                    noise: "vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857;\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}",
                    blend: "vec3 blendNormal(vec3 base, vec3 blend) {\n\treturn blend;\n}\n\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\n}",
                    fragment: "varying vec3 v_color;\n\nvoid main() {\n  vec3 color = v_color;\n  if (u_darken_top == 1.0) {\n    vec2 st = gl_FragCoord.xy/resolution.xy;\n    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;\n  }\n  gl_FragColor = vec4(color, 1.0);\n}"
                };
                this.conf = { presetName: "", wireframe: false, density: [.06, .16], zoom: 1, rotation: 0, playing: true };
                this.t = 1253106;
                this.last = 0;
                this.width = undefined;
                this.minWidth = 1111;
                this.height = 600;
                this.xSegCount = undefined;
                this.ySegCount = undefined;
                this.mesh = undefined;
                this.material = undefined;
                this.geometry = undefined;
                this.minigl = undefined;
                this.amp = 320;
                this.seed = 5;
                this.freqX = 14e-5;
                this.freqY = 29e-5;
                this.freqDelta = 1e-5;
                this.activeColors = [1, 1, 1, 1];
                this.isMouseDown = false;
            }

            initGradient(selector) {
                this.el = document.querySelector(selector);
                this.connect();
                return this;
            }

            connect() {
                this.minigl = new MiniGl(this.el, null, null, true);
                requestAnimationFrame(() => {
                    this.el && (this.computedCanvasStyle = getComputedStyle(this.el), this.waitForCssVars());
                });
            }

            initMaterial() {
                this.uniforms = {
                    u_time: new this.minigl.Uniform({ value: 0 }),
                    u_shadow_power: new this.minigl.Uniform({ value: 5 }),
                    u_darken_top: new this.minigl.Uniform({ value: "" === this.el.dataset.jsDarkenTop ? 1 : 0 }),
                    u_active_colors: new this.minigl.Uniform({ value: this.activeColors, type: "vec4" }),
                    u_global: new this.minigl.Uniform({
                        value: {
                            noiseFreq: new this.minigl.Uniform({ value: [this.freqX, this.freqY], type: "vec2" }),
                            noiseSpeed: new this.minigl.Uniform({ value: 5e-6 })
                        },
                        type: "struct"
                    }),
                    u_vertDeform: new this.minigl.Uniform({
                        value: {
                            incline: new this.minigl.Uniform({ value: Math.sin(this.angle) / Math.cos(this.angle) }),
                            offsetTop: new this.minigl.Uniform({ value: -.5 }),
                            offsetBottom: new this.minigl.Uniform({ value: -.5 }),
                            noiseFreq: new this.minigl.Uniform({ value: [3, 4], type: "vec2" }),
                            noiseAmp: new this.minigl.Uniform({ value: this.amp }),
                            noiseSpeed: new this.minigl.Uniform({ value: 10 }),
                            noiseFlow: new this.minigl.Uniform({ value: 3 }),
                            noiseSeed: new this.minigl.Uniform({ value: this.seed })
                        },
                        type: "struct",
                        excludeFrom: "fragment"
                    }),
                    u_baseColor: new this.minigl.Uniform({ value: this.sectionColors[0], type: "vec3", excludeFrom: "fragment" }),
                    u_waveLayers: new this.minigl.Uniform({ value: [], excludeFrom: "fragment", type: "array" })
                };
                for (let e = 1; e < this.sectionColors.length; e += 1) {
                    this.uniforms.u_waveLayers.value.push(new this.minigl.Uniform({
                        value: {
                            color: new this.minigl.Uniform({ value: this.sectionColors[e], type: "vec3" }),
                            noiseFreq: new this.minigl.Uniform({ value: [2 + e / this.sectionColors.length, 3 + e / this.sectionColors.length], type: "vec2" }),
                            noiseSpeed: new this.minigl.Uniform({ value: 11 + .3 * e }),
                            noiseFlow: new this.minigl.Uniform({ value: 6.5 + .3 * e }),
                            noiseSeed: new this.minigl.Uniform({ value: this.seed + 10 * e }),
                            noiseFloor: new this.minigl.Uniform({ value: .1 }),
                            noiseCeil: new this.minigl.Uniform({ value: .63 + .07 * e })
                        },
                        type: "struct"
                    }));
                }
                this.vertexShader = [this.shaderFiles.noise, this.shaderFiles.blend, this.shaderFiles.vertex].join("\n\n");
                return new this.minigl.Material(this.vertexShader, this.shaderFiles.fragment, this.uniforms);
            }

            initMesh() {
                this.material = this.initMaterial();
                this.geometry = new this.minigl.PlaneGeometry();
                this.mesh = new this.minigl.Mesh(this.geometry, this.material);
            }

            resize() {
                this.width = window.innerWidth;
                this.minigl.setSize(this.width, this.height);
                this.minigl.setOrthographicCamera();
                this.xSegCount = Math.ceil(this.width * this.conf.density[0]);
                this.ySegCount = Math.ceil(this.height * this.conf.density[1]);
                this.mesh.geometry.setTopology(this.xSegCount, this.ySegCount);
                this.mesh.geometry.setSize(this.width, this.height);
                this.mesh.material.uniforms.u_shadow_power.value = this.width < 600 ? 5 : 6;
            }

            animate(e) {
                if (!this.shouldSkipFrame(e) || this.isMouseDown) {
                    this.t += Math.min(e - this.last, 1e3 / 15);
                    this.last = e;
                    this.mesh.material.uniforms.u_time.value = this.t;
                    this.minigl.render();
                }
                if (this.conf.playing || this.isMouseDown) {
                    requestAnimationFrame(this.animate.bind(this));
                }
            }

            shouldSkipFrame(e) {
                return !!window.document.hidden || (!this.conf.playing || (parseInt(e, 10) % 2 === 0));
            }

            initGradientColors() {
                this.sectionColors = [
                    normalizeColor(0x000000),
                    normalizeColor(0x000000),
                    normalizeColor(0x000000),
                    normalizeColor(0x333333)
                ];
            }

            waitForCssVars() {
                if (this.computedCanvasStyle && this.computedCanvasStyle.getPropertyValue("--gradient-color-1").indexOf("#") !== -1) {
                    this.init();
                    this.addIsLoadedClass();
                } else {
                    this.cssVarRetries += 1;
                    if (this.cssVarRetries > this.maxCssVarRetries) {
                        this.sectionColors = [
                            normalizeColor(0x000000),
                            normalizeColor(0x000000),
                            normalizeColor(0x000000),
                            normalizeColor(0x333333)
                        ];
                        this.init();
                    } else {
                        requestAnimationFrame(() => this.waitForCssVars());
                    }
                }
            }

            addIsLoadedClass() {
                if (!this.isLoadedClass) {
                    this.isLoadedClass = true;
                    this.el.classList.add("isLoaded");
                    setTimeout(() => this.el.parentElement.classList.add("isLoaded"), 3e3);
                }
            }

            init() {
                this.initGradientColors();
                this.initMesh();
                this.resize();
                requestAnimationFrame(this.animate.bind(this));
                window.addEventListener("resize", this.resize.bind(this));
                setTimeout(() => {
                    document.body.classList.remove('loading');
                    window.removeEventListener('scroll', lockScroll);
                    window.scrollTo(0, 0);
                }, 0);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            var gradient = new Gradient();
            gradient.initGradient("#gradient-canvas");

            animatedElements.forEach(el => {
                el.style.animationPlayState = 'running';
            });

            const popupOverlay = document.getElementById('popup-overlay');
            const contactLinks = document.querySelectorAll('.contact-link');
            const contactForm = document.getElementById('contact-form');
            const closeBtn = document.getElementById('close-btn');

            contactLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    popupOverlay.style.display = 'flex';
                    document.body.style.overflow = 'hidden';
                });
            });

            popupOverlay.addEventListener('click', (e) => {
                if (e.target === popupOverlay) {
                    popupOverlay.style.display = 'none';
                    document.body.style.overflow = 'auto';
                }
            });

            closeBtn.addEventListener('click', () => {
                popupOverlay.style.display = 'none';
                document.body.style.overflow = 'auto';
            });

            contactForm.addEventListener('submit', (e) => {
                const message = document.querySelector('textarea[name="message"]').value.trim();
                const name = document.querySelector('input[name="name"]').value.trim();
                const email = document.querySelector('input[name="email"]').value.trim();
                if (!message || !name || !email) {
                    e.preventDefault();
                    alert('Please fill in all fields (Name, Email, and Message).');
                } else {
                    setTimeout(() => {
                        popupOverlay.style.display = 'none';
                        document.body.style.overflow = 'auto';
                        document.querySelector('textarea[name="message"]').value = '';
                        document.querySelector('input[name="name"]').value = '';
                        document.querySelector('input[name="email"]').value = '';
                        alert('Message sent! Please check your email to confirm the first submission.');
                    }, 500);
                }
            });

            const progressBar = document.querySelector('.progress');
            if (progressBar) {
                const startProgress = () => {
                    if (!document.body.classList.contains('loading')) {
                        setTimeout(() => {
                            progressBar.classList.add('fade-out');
                            setTimeout(() => {
                                progressBar.style.display = 'none';
                            }, 50);
                        }, 50);
                    } else {
                        requestAnimationFrame(startProgress);
                    }
                };
                requestAnimationFrame(startProgress);
            }
        });
    </script>
</body>
</html>
